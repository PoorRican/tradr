from abc import ABC
from datetime import datetime
import pandas as pd
from pytz import timezone
from typing import Union, Tuple, Sequence

from analysis.financials import FinancialsMixin
from models.signals import Signal, IndicatorContainer, INDICATOR
from models.trades import Side


class OscillatingStrategy(FinancialsMixin, ABC):
    def __init__(self, *args, indicators: Sequence[INDICATOR], timeout: str = '6h', **kwargs):
        super().__init__(*args, **kwargs)

        self.timeout: str = timeout
        self.indicators: IndicatorContainer = IndicatorContainer(indicators)

    def _oscillation(self, signal: Signal, timeout=True) -> bool:
        """ Ensure that order types oscillate between `sell` and `buy`.

        Both the first order and `timeout` are taken into account.

        Check that `signal` (which is generated by `_check_signals()`) is the opposite of the last order type. If
        timeout has been reached, then multiple buy orders are allowed. Multiple buy orders are tracked by
        `FinancialsMixin.incomplete` and are limited by `order_count`.

        Args:
            signal:
                decision generated by `_check_signals()`. May be `False`, 'sell' or 'buy'
            timeout:
                flag to check timeout period. Used for unit tests.

        Returns:
            `true` if `signal`  decision values.
        """
        if self.orders.empty:
            # force buy for first trade
            return signal == Signal.BUY

        if signal:
            last_order = self.orders.iloc[-1]
            if last_order['side'] == signal == Signal.BUY and self._remaining and timeout:
                # Allow repeated buys on timeout
                inactive = self._check_timeout()
                if inactive:
                    # Add repeated buy to `unpaired_buys`
                    self._handle_inactive(last_order)
                return inactive
            return last_order.side != signal

        return False

    def _determine_position(self, point: pd.Timestamp = None) -> Union[Tuple[Side, 'pd.Timestamp'], 'False']:
        """ Determine trade execution and type.

        Oscillation of trade types is executed here. Duplicate trade type is not returned if a new signal is
        generated.

        Notes:
            `self.indicators.develop()` needs to be called beforehand.
        """
        if not point:
            point = self.market.data.iloc[-1].name

        signal: Signal = self.indicators.check(self.market.data, point)
        if self._oscillation(signal):
            signal: Side = Side(signal)
            rate = self._calc_rate(point, signal)
            amount = self._calc_amount(point, signal)
            if self._is_profitable(amount, rate, signal, point):
                return signal, point

        return False

    def _check_timeout(self) -> bool:
        """ Allows the consecutive orders of the same type if inactivity exceeds timeout.

        Notes:
            Logic definitions for when timeout is valid (ie: repeating buys) should be performed before.

        Returns:
            True if alternation needs to be reset; False if last order wasn't a buy, or if timeout hasn't been reached.

        Raises:
            `IndexError` if `orders` is empty.
        """
        last_order = self.orders.iloc[-1]
        now = datetime.now(tz=timezone('US/Pacific'))
        diff = now - last_order.name
        period = pd.to_timedelta(self.timeout)

        return diff > period
