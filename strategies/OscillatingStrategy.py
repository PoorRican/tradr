from typing import Union, Tuple, Sequence
from abc import ABC, abstractmethod
from datetime import datetime
import pandas as pd

from strategies.strategy import Strategy
from models.signals import Signal, IndicatorContainer, INDICATOR
from models.trades import SuccessfulTrade, Side


class OscillatingStrategy(Strategy, ABC):
    def __init__(self, *args, indicators: Sequence[INDICATOR], timeout: str = '6h', **kwargs):
        super().__init__(*args, **kwargs)

        self.unpaired_buys: pd.Series = pd.Series(name='unpaired buy id\'s', dtype='int32')

        self.timeout: str = timeout
        self.indicators: IndicatorContainer = IndicatorContainer(indicators)

    @abstractmethod
    def _calc_amount(self, extrema: pd.Timestamp, side: Side) -> float:
        pass

    @abstractmethod
    def _is_profitable(self, amount: float, rate: float, side: Side) -> bool:
        pass

    def _oscillation(self, signal: Signal, timeout=True) -> bool:
        """ Ensure that order types oscillate between `sell` and `buy`.

        Both the first order and `timeout` are taken into account.

        Check that `signal` (which is generated by `_check_signals()`) is the opposite
        of the last order type. If timeout has been reached, add last 'buy' to `unpaired_buys`

        Args:
            signal: decision generated by `_check_signals()`. May be `False`, 'sell' or 'buy'
            timeout: flag to analyze timeout. Used for unit tests.

        Returns:
            `true` if `signal`  decision values.
        """
        if self.orders.empty:
            # force buy for first trade
            return signal == Signal.BUY

        if signal:
            last_order = self.orders.iloc[-1]
            if last_order['side'] == signal == Signal.BUY and timeout:
                # Allow repeated buys on timeout
                inactive = self._check_timeout()
                if inactive:
                    # Add repeated buy to `unpaired_buys`
                    row = pd.Series([last_order['id']])
                    self.unpaired_buys = pd.concat([self.unpaired_buys, row],
                                                   ignore_index=True, names=['id\'s'])
                return inactive
            return last_order.side != signal

        return False

    def _post_sale(self, trade: SuccessfulTrade):
        """ Clean `unpaired_buys` after successful sale.
        """
        if trade.side == Side.SELL:
            unpaired = self._check_unpaired(trade.rate)
            if not unpaired.empty:
                matching = self.unpaired_buys.isin(unpaired['id'].values)
                indices = self.unpaired_buys.loc[matching].index
                self.unpaired_buys.drop(index=indices, inplace=True)

    def _determine_position(self, point: pd.Timestamp = None) -> Union[Tuple[Side, 'pd.Timestamp'], 'False']:
        """ Determine trade execution and type.

        Oscillation of trade types is executed here. Duplicate trade type is not returned if a new signal is
        generated.

        Notes:
            `self.indicators.develop()` needs to be called beforehand.
        """
        if not point:
            point = self.market.data.iloc[-1].name

        signal: Signal = self.indicators.check(self.market.data, point)
        if self._oscillation(signal):
            signal: Side = Side(signal)
            rate = self._calc_rate(point, signal)
            amount = self._calc_amount(point, signal)
            if self._is_profitable(amount, rate, signal):
                return signal, point

        return False

    @abstractmethod
    def _calc_rate(self, extrema: pd.Timestamp, side: Side) -> float:
        pass

    def get_unpaired_orders(self) -> pd.DataFrame:
        """ Select of unpaired orders by cross-referencing `unpaired_buys` """
        return self.orders[self.orders['id'].isin(self.unpaired_buys.values)]

    def _check_unpaired(self, rate: float):
        """ Get any unpaired orders that can be sold at a profit. """
        unpaired = self.get_unpaired_orders()
        return unpaired[unpaired['rate'] <= rate]

    def unrealized_gain(self) -> float:
        """ Calculate max potential gain if all unpaired orders were sold at the highest rate.

        Returns:
            Value of unsold assets sold at most expensive price.
        """
        unpaired = self.get_unpaired_orders()
        highest = max(unpaired['rate'])
        return unpaired['amt'].sum() * highest

    def _check_timeout(self) -> bool:
        """ Allows the consecutive orders of the same type if inactivity exceeds timeout.

        Notes:
            Logic definitions for when timeout is valid (ie: repeating buys) should be performed before.

        Returns:
            True if alternation needs to be reset; False if last order wasn't a buy, or if timeout hasn't been reached.

        Raises:
            `IndexError` if `orders` is empty.
        """
        last_order = self.orders.iloc[-1]
        now = datetime.now()
        diff = now - last_order.name
        period = pd.to_timedelta(self.timeout)

        return diff > period
